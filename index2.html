<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>KakaoMap Live Navigation Widget</title>
    <style>
        html, body {width:100%;height:100%;margin:0;padding:0;}
        #map {width:100%;height:calc(100% - 150px);}
        #info-container {padding: 10px; background-color: #f1f1f1;}
        #route-info {font-weight: bold;}
    </style>
</head>
<body>
    <div id="info-container">
        <p>
            Destination: <span id="destination-text"></span>
        </p>
        <div id="route-info"></div>
    </div>
    <div id="map"></div>
    
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_JS_KEY&libraries=services"></script>
    
    <script>
        // === IMPORTANT: Replace these with your actual keys ===
        const KAKAO_JS_KEY = '00a03dac8488d12731e4021756938e72'; // Your JavaScript key for map display
        const KAKAO_REST_KEY = 'dad89b90a6acaa5acadc74e2329cab63'; // Your REST API key for directions

        // Define the destination address from the URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const destinationAddress = urlParams.get('destination') || '대한민국 서울특별시 중구 세종대로 110'; // Default destination: Seoul City Hall
        document.getElementById('destination-text').innerText = destinationAddress;

        // Initialize the map and services
        const mapContainer = document.getElementById('map');
        const mapOption = { center: new kakao.maps.LatLng(37.566826, 126.9786567), level: 3 };
        const map = new kakao.maps.Map(mapContainer, mapOption);
        const geocoder = new kakao.maps.services.Geocoder();
        
        let userMarker = new kakao.maps.Marker({
            map: map,
            image: new kakao.maps.MarkerImage(
                'https://i.imgur.com/gK52L9o.png', // A custom marker for the user's position
                new kakao.maps.Size(30, 40)
            )
        });
        let polyline;
        let destinationCoords;

        // Geocode the destination address once at the start
        function geocodeDestination() {
            return new Promise((resolve, reject) => {
                geocoder.addressSearch(destinationAddress, function(result, status) {
                    if (status === kakao.maps.services.Status.OK) {
                        destinationCoords = new kakao.maps.LatLng(result[0].y, result[0].x);
                        new kakao.maps.Marker({ map: map, position: destinationCoords });
                        resolve();
                    } else {
                        reject(new Error(`Could not find destination: ${destinationAddress}`));
                    }
                });
            });
        }

        // Start the real-time tracking process
        async function startNavigation() {
            try {
                await geocodeDestination();
                
                if (navigator.geolocation) {
                    navigator.geolocation.watchPosition(updatePosition, handleGeolocationError, {
                        enableHighAccuracy: true,
                        maximumAge: 0
                    });
                } else {
                    alert("Geolocation is not supported by your browser.");
                }
            } catch (error) {
                console.error("Error during navigation setup:", error);
                alert(error.message);
            }
        }

        // Main function to handle position updates
        let lastPositionTime = 0;
        const MIN_UPDATE_INTERVAL = 10000; // 10 seconds in milliseconds
        
        async function updatePosition(position) {
            const currentCoords = new kakao.maps.LatLng(position.coords.latitude, position.coords.longitude);
            userMarker.setPosition(currentCoords);
            map.setCenter(currentCoords);

            // Only update the route and info every 10 seconds
            const now = Date.now();
            if (now - lastPositionTime > MIN_UPDATE_INTERVAL) {
                lastPositionTime = now;
                try {
                    const routeData = await fetchBicycleRoute(currentCoords, destinationCoords);
                    drawRoute(routeData);
                    displayRouteInfo(routeData);
                } catch (error) {
                    console.error("Error fetching route:", error);
                }
            }
        }

        // Handle geolocation errors
        function handleGeolocationError(error) {
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    alert("User denied the request for Geolocation.");
                    break;
                case error.POSITION_UNAVAILABLE:
                    alert("Location information is unavailable.");
                    break;
                case error.TIMEOUT:
                    alert("The request to get user location timed out.");
                    break;
                case error.UNKNOWN_ERROR:
                    alert("An unknown error occurred.");
                    break;
            }
        }

        // Helper function to fetch the bicycle route from the REST API
        async function fetchBicycleRoute(start, end) {
            const url = 'https://apis-navi.kakaomobility.com/v1/directions';
            const headers = { 'Authorization': `KakaoAK ${KAKAO_REST_KEY}` };
            const body = new URLSearchParams({
                origin: `${start.getLng()},${start.getLat()}`,
                destination: `${end.getLng()},${end.getLat()}`,
                car_fuel: 'bycicle'
            });
            const response = await fetch(url, { method: 'POST', headers: headers, body: body });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${errorData.msg || 'Unknown error'}`);
            }
            return response.json();
        }

        // Helper function to draw the polyline on the map
        function drawRoute(routeData) {
            const lines = routeData.routes[0].sections.flatMap(section => 
                section.roads.flatMap(road => 
                    road.vertexes.map((_, i, arr) => {
                        if (i % 2 === 0 && i < arr.length - 1) {
                            return new kakao.maps.LatLng(arr[i+1], arr[i]);
                        }
                    }).filter(Boolean)
                )
            );

            if (polyline) polyline.setMap(null);

            polyline = new kakao.maps.Polyline({
                path: lines,
                strokeWeight: 5,
                strokeColor: '#0055ff',
                strokeOpacity: 0.7,
                strokeStyle: 'solid'
            });

            polyline.setMap(map);
        }

        // Helper function to display route information
        function displayRouteInfo(routeData) {
            const route = routeData.routes[0];
            const distance = (route.summary.distance / 1000).toFixed(1); // km
            const duration = Math.round(route.summary.duration / 60); // minutes
            document.getElementById('route-info').innerHTML = 
                `Time: ${duration} mins, Distance: ${distance} km`;
        }

        // Start the process when the page loads
        startNavigation();
    </script>
</body>
</html>
