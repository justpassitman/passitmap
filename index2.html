import { useState, useRef, useEffect } from 'react';
import * as THREE from 'three';

// Import and use a responsive icon from a library like lucide-react
import { Play, Pause, RotateCcw } from 'lucide-react';

// Main application component
export default function App() {
  // State for controlling play/pause functionality
  const [isPlaying, setIsPlaying] = useState(true);
  const canvasRef = useRef(null);
  const cameraRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const particlesRef = useRef(null);
  const velocitiesRef = useRef([]);
  const animationFrameRef = useRef(null);

  // Initialize the Three.js scene
  useEffect(() => {
    // Canvas setup
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Dimensions
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;

    // Create scene, camera, and renderer
    const scene = new THREE.Scene();
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 5;
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    rendererRef.current = renderer;

    // Create particles
    const particleCount = 1000;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    velocitiesRef.current = [];

    // Generate particles with random positions and velocities
    for (let i = 0; i < particleCount; i++) {
      // Position
      positions.push(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5);

      // Velocity (increased by a factor of 20)
      velocitiesRef.current.push(
        (Math.random() - 0.5) * 0.05 * 20, // X velocity
        (Math.random() - 0.5) * 0.05 * 20, // Y velocity
        (Math.random() - 0.5) * 0.05 * 20  // Z velocity
      );
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

    // Material (size of dots is 1/10th of the previous value)
    // Removed blending and vertexColors for a solid, non-glowing green dot
    const material = new THREE.PointsMaterial({
      size: 0.01,
      color: 0x00ff00
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
    particlesRef.current = particles;

    // Handle window resizing
    const handleResize = () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup function
    return () => {
      window.removeEventListener('resize', handleResize);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      renderer.dispose();
    };
  }, []);

  // Animation loop
  useEffect(() => {
    const animate = () => {
      if (!isPlaying) {
        return;
      }

      const particles = particlesRef.current;
      const velocities = velocitiesRef.current;
      if (particles) {
        const positions = particles.geometry.attributes.position.array;
        
        // Update particle positions based on velocity
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += velocities[i];
          positions[i + 1] += velocities[i + 1];
          positions[i + 2] += velocities[i + 2];

          // Simple boundary check to wrap particles around
          if (positions[i] > 5 || positions[i] < -5) velocities[i] *= -1;
          if (positions[i + 1] > 5 || positions[i + 1] < -5) velocities[i + 1] *= -1;
          if (positions[i + 2] > 5 || positions[i + 2] < -5) velocities[i + 2] *= -1;
        }

        particles.geometry.attributes.position.needsUpdate = true;
      }

      rendererRef.current.render(sceneRef.current, cameraRef.current);
      animationFrameRef.current = requestAnimationFrame(animate);
    };

    if (isPlaying) {
      animate();
    } else {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    }

    // Return a cleanup function
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isPlaying]);

  // Handle camera rotation with mouse movement
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    let isDragging = false;
    let previousMousePosition = {
      x: 0,
      y: 0
    };

    const handleMouseDown = (e) => {
      isDragging = true;
      previousMousePosition = {
        x: e.clientX,
        y: e.clientY
      };
    };

    const handleMouseUp = () => {
      isDragging = false;
    };

    const handleMouseMove = (e) => {
      if (!isDragging || !cameraRef.current) return;

      const deltaMove = {
        x: e.clientX - previousMousePosition.x,
        y: e.clientY - previousMousePosition.y
      };

      const rotationSpeed = 0.005;

      const newRotationY = cameraRef.current.rotation.y - deltaMove.x * rotationSpeed;
      const newRotationX = cameraRef.current.rotation.x - deltaMove.y * rotationSpeed;

      cameraRef.current.rotation.y = newRotationY;
      cameraRef.current.rotation.x = newRotationX;

      previousMousePosition = {
        x: e.clientX,
        y: e.clientY
      };
    };

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mousemove', handleMouseMove);

    return () => {
      canvas.removeEventListener('mousedown', handleMouseDown);
      canvas.removeEventListener('mouseup', handleMouseUp);
      canvas.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  const handleReset = () => {
    // Reset camera position and rotation
    const camera = cameraRef.current;
    if (camera) {
      camera.position.set(0, 0, 5);
      camera.rotation.set(0, 0, 0);
    }

    // Reset particle positions and velocities
    const particles = particlesRef.current;
    if (particles) {
      const positions = particles.geometry.attributes.position.array;
      const velocities = velocitiesRef.current;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] = Math.random() * 10 - 5;
        positions[i + 1] = Math.random() * 10 - 5;
        positions[i + 2] = Math.random() * 10 - 5;

        velocities[i] = (Math.random() - 0.5) * 0.05 * 20;
        velocities[i + 1] = (Math.random() - 0.5) * 0.05 * 20;
        velocities[i + 2] = (Math.random() - 0.5) * 0.05 * 20;
      }
      particles.geometry.attributes.position.needsUpdate = true;
    }
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen w-screen bg-gray-900 text-white font-sans overflow-hidden">
      <div className="absolute top-0 left-0 right-0 p-4 z-10 flex justify-center space-x-4">
        <button
          onClick={() => setIsPlaying(!isPlaying)}
          className="p-3 bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow-lg transition-transform transform hover:scale-105 active:scale-95 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
          title={isPlaying ? "Pause" : "Play"}
        >
          {isPlaying ? <Pause size={24} /> : <Play size={24} />}
        </button>
        <button
          onClick={handleReset}
          className="p-3 bg-gray-700 hover:bg-gray-600 text-white rounded-full shadow-lg transition-transform transform hover:scale-105 active:scale-95 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50"
          title="Reset"
        >
          <RotateCcw size={24} />
        </button>
      </div>
      <canvas ref={canvasRef} className="block w-full h-full" />
    </div>
  );
}
