<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Delivery Livestream Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: transparent;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .widget-container {
            /*
            * The background of the entire widget container is now transparent.
            */
            background-color: rgba(255, 255, 255, 0);
            position: fixed;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 188px;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .map-container {
            flex-grow: 1;
            padding: 0;
            height: 100%;
            border-radius: 0;
            box-shadow: none;
            position: relative;
        }

        .header {
            background-color: #6a0dad;
            color: white;
            font-size: 0.875rem;
            font-weight: 600;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .duck {
            animation: quack 1s infinite;
        }

        @keyframes quack {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
            100% { transform: rotate(0deg); }
        }

        .timer-container {
            background-color: #ffffff;
            color: #1f2937;
            padding: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            border-top: 1px solid #e5e7eb;
            height: 24px;
        }

        .error-message {
            color: #dc2626;
            font-weight: 600;
            text-align: center;
            padding-top: 10px;
        }

        .pulse-pin {
            position: relative;
        }

        .pulse-pin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: #FF0000;
            border-radius: 50%;
            opacity: 0;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="widget-container">
        <div class="header">
            <span>Duck Delivery</span>
            <span id="duckIcon" class="duck">ðŸ¦†</span>
        </div>
        <div class="map-container" id="map"></div>
        <div class="timer-container" id="timer"></div>
    </div>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_KAKAO_API_KEY_HERE&libraries=services"></script>
    <script>
        (function() {
            // =================================================================================================================
            // Configuration & State Variables
            // =================================================================================================================
            const KAKAO_API_KEY = "YOUR_KAKAO_API_KEY_HERE"; // Replace with your Kakao API key.
            const INITIAL_POSITION = new kakao.maps.LatLng(33.450701, 126.570667); // Default location if geolocation fails
            const destinationCoords = new kakao.maps.LatLng(33.45013, 126.57245); // Hardcoded destination
            const AVERAGE_SPEED_KMPH = 15; // Average speed for delivery duck in km/h
            const ROUTING_API_URL = "https://apis-navi.kakaomobility.com/v1/directions";

            // Map and UI elements
            let map = null;
            let currentPolyline = null;
            let currentMarker = null;
            let timerContainer = document.getElementById('timer');
            let duckIcon = document.getElementById('duckIcon');
            let locationWatchId = null;
            let duckQuackInterval = null;

            // State for the one-time routing API call
            let fullPolyline = null;
            let routeIsFetched = false;

            // =================================================================================================================
            // UI & Animation Functions
            // =================================================================================================================
            function startQuacking() {
                if (duckQuackInterval === null) {
                    duckQuackInterval = setInterval(() => {
                        duckIcon.classList.add('quack-animation');
                        setTimeout(() => {
                            duckIcon.classList.remove('quack-animation');
                        }, 500);
                    }, 5000);
                }
            }

            function stopQuacking() {
                if (duckQuackInterval !== null) {
                    clearInterval(duckQuackInterval);
                    duckQuackInterval = null;
                }
            }
            
            // =================================================================================================================
            // Helper Functions for Geolocation & Distance Calculation
            // =================================================================================================================
            function toRadians(deg) {
                return deg * (Math.PI / 180);
            }

            // Haversine formula to calculate distance between two lat/lng points
            function calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // metres
                const Ï†1 = toRadians(lat1);
                const Ï†2 = toRadians(lat2);
                const Î”Ï† = toRadians(lat2 - lat1);
                const Î”Î» = toRadians(lon2 - lon1);

                const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                        Math.cos(Ï†1) * Math.cos(Ï†2) *
                        Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // in meters
            }

            // =================================================================================================================
            // Main Logic & API Calls
            // =================================================================================================================

            // This function now fetches the FULL route only once.
            async function getFullRoute(startPos, endPos) {
                try {
                    const origin = `${startPos.getLng()},${startPos.getLat()}`;
                    const destination = `${endPos.getLng()},${endPos.getLat()}`;

                    const response = await fetch(`${ROUTING_API_URL}?origin=${origin}&destination=${destination}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `KakaoAK ${KAKAO_API_KEY}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Routing API call failed with status: ${response.status}`);
                    }

                    const data = await response.json();
                    if (data.routes && data.routes.length > 0) {
                        return data.routes[0].sections[0].roads.flatMap(road => road.vertexes)
                                   .map((v, i, arr) => (i % 2 === 0) ? new kakao.maps.LatLng(arr[i + 1], arr[i]) : null)
                                   .filter(v => v !== null);
                    } else {
                        throw new Error("No route found.");
                    }
                } catch (error) {
                    console.error("Routing Error:", error);
                    return null;
                }
            }

            // This function now updates the UI based on the pre-fetched route, no API calls here.
            function updateRouteOnMap(currentPos) {
                if (!map || !fullPolyline) {
                    console.warn("Map or full polyline not initialized.");
                    return;
                }

                // 1. Find the closest point on the original polyline to the current user location.
                let minDistance = Infinity;
                let closestPointIndex = -1;
                let remainingDistance = 0;

                for (let i = 0; i < fullPolyline.length; i++) {
                    const distance = calculateDistance(currentPos.getLat(), currentPos.getLng(), fullPolyline[i].getLat(), fullPolyline[i].getLng());
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPointIndex = i;
                    }
                }

                // 2. Shorten the polyline to represent the remaining path.
                const remainingPolyline = fullPolyline.slice(closestPointIndex);
                if (currentPolyline) {
                    currentPolyline.setPath(remainingPolyline);
                } else {
                    currentPolyline = new kakao.maps.Polyline({
                        path: remainingPolyline,
                        strokeWeight: 5,
                        strokeColor: '#FF6347',
                        strokeOpacity: 0.7,
                        strokeStyle: 'solid'
                    });
                    currentPolyline.setMap(map);
                }

                // 3. Recalculate remaining distance and time.
                for (let i = 0; i < remainingPolyline.length - 1; i++) {
                    remainingDistance += calculateDistance(
                        remainingPolyline[i].getLat(),
                        remainingPolyline[i].getLng(),
                        remainingPolyline[i+1].getLat(),
                        remainingPolyline[i+1].getLng()
                    );
                }

                const durationInSeconds = (remainingDistance / 1000) / (AVERAGE_SPEED_KMPH / 60 / 60);
                const durationInMinutes = Math.round(durationInSeconds / 60);

                if (timerContainer) {
                    timerContainer.innerHTML = `<b>${durationInMinutes} min</b>`;
                }

                // 4. Update the duck marker position
                if (currentMarker) {
                    currentMarker.setPosition(currentPos);
                } else {
                    const imageSize = new kakao.maps.Size(36, 36);
                    const imageOption = {offset: new kakao.maps.Point(18, 36)};
                    const markerImage = new kakao.maps.MarkerImage('https://cdn.iconscout.com/icon/free/png-256/duck-320-459140.png', imageSize, imageOption);
                    currentMarker = new kakao.maps.Marker({
                        position: currentPos,
                        image: markerImage,
                        map: map
                    });
                }
            }


            // This is the main geolocation success callback function.
            function onLocationSuccess(position) {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const currentPos = new kakao.maps.LatLng(lat, lng);

                if (!map) {
                    const mapContainer = document.getElementById('map');
                    const mapOption = {
                        center: currentPos,
                        level: 5
                    };
                    map = new kakao.maps.Map(mapContainer, mapOption);
                    new kakao.maps.Marker({
                        position: destinationCoords,
                        map: map
                    });

                    // Add a destination pulse pin using a custom overlay
                    const destinationPin = `<div class="pulse-pin"></div>`;
                    new kakao.maps.CustomOverlay({
                        map: map,
                        position: destinationCoords,
                        content: destinationPin,
                        yAnchor: 1.5
                    });
                }

                // Only make the routing call once.
                if (!routeIsFetched) {
                    routeIsFetched = true;
                    // Initial, one-time API call for the full route
                    getFullRoute(currentPos, destinationCoords).then(polyline => {
                        if (polyline) {
                            fullPolyline = polyline;
                            // Update map with the initial position and full route
                            updateRouteOnMap(currentPos);
                            map.setBounds(new kakao.maps.LatLngBounds(currentPos, destinationCoords));
                            startQuacking();
                        } else {
                            if (timerContainer) {
                                timerContainer.innerHTML = "Routing data could not be found.";
                            }
                            stopQuacking();
                        }
                    });
                } else {
                    // Subsequent updates use the stored fullPolyline
                    updateRouteOnMap(currentPos);
                }
            }

            function onLocationError(error) {
                console.error("Geolocation Error:", error);
                const errorMessage = `Geolocation failed: ${error.message}`;
                if (timerContainer) {
                    timerContainer.innerHTML = errorMessage;
                }
                stopQuacking();
            }

            function initGeolocation() {
                if ('geolocation' in navigator) {
                    locationWatchId = navigator.geolocation.watchPosition(onLocationSuccess, onLocationError, {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    });
                } else {
                    if (timerContainer) {
                        timerContainer.innerHTML = "Geolocation is not supported by this browser.";
                    }
                }
            }

            // Main initialization function
            function init() {
                const mapContainer = document.getElementById('map');
                if (KAKAO_API_KEY.includes("YOUR_KAKAO_API_KEY")) {
                    mapContainer.innerHTML = '<div class="error-message">Please replace YOUR_KAKAO_API_KEY_HERE with your actual key.</div>';
                    return;
                }

                if (typeof kakao !== 'undefined' && kakao.maps) {
                    initGeolocation();
                } else {
                    if (mapContainer) {
                        mapContainer.innerHTML = '<div class="error-message">Kakao Maps API failed to load. Please check your script tag and API key.</div>';
                    }
                }
            }

            // Load the map when the page is ready
            if (typeof kakao !== 'undefined' && kakao.maps) {
                kakao.maps.load(function() {
                    init();
                });
            } else {
                const mapContainer = document.getElementById('map');
                if (mapContainer) {
                    mapContainer.innerHTML = '<div class="error-message">Kakao Maps API failed to load. Please check your script tag and API key.</div>';
                }
            }
        })();
    </script>
</body>
</html>
