<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Duck Delivery Widget</title>
Â  Â  Â  Â  <script src="https://cdn.tailwindcss.com"></script>
Â  Â  <style>
Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  background-color: transparent;Â 
Â  Â  Â  Â  Â  Â  font-family: 'Inter', sans-serif;
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .widget-container {
Â  Â  Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  Â  Â  top: 20px;
Â  Â  Â  Â  Â  Â  right: 20px;
Â  Â  Â  Â  Â  Â  /* New dimensions reduced by 20% */
Â  Â  Â  Â  Â  Â  width: 144px;
Â  Â  Â  Â  Â  Â  height: 180.48px;
Â  Â  Â  Â  Â  Â  background-color: rgba(255, 255, 255, 0.5); /* Translucent background */
Â  Â  Â  Â  Â  Â  border-radius: 0.75rem; /* Adjusted border-radius for the larger size */
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
Â  Â  Â  Â  Â  Â  z-index: 1000;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  /* Add backdrop-filter for a blurred glass effect */
Â  Â  Â  Â  Â  Â  backdrop-filter: blur(8px);
Â  Â  Â  Â  Â  Â  -webkit-backdrop-filter: blur(8px);
Â  Â  Â  Â  }

Â  Â  Â  Â  .map-container {
Â  Â  Â  Â  Â  Â  flex-grow = 1;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  border-radius: 0;
Â  Â  Â  Â  Â  Â  box-shadow: none;
Â  Â  Â  Â  Â  Â  position: relative; /* Add this to make .timer-container's position absolute relative to the map container */
Â  Â  Â  Â  }

Â  Â  Â  Â  #map {
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  .timer-container {
Â  Â  Â  Â  Â  Â  /* Changed to absolute positioning and moved inside the map container */
Â  Â  Â  Â  Â  Â  position: absolute;Â 
Â  Â  Â  Â  Â  Â  bottom: 0.75rem; /* Adjusted padding for the larger size */
Â  Â  Â  Â  Â  Â  left: 50%; /* Center the element horizontally */
Â  Â  Â  Â  Â  Â  transform: translateX(-50%); /* Adjust for the element's width */
Â  Â  Â  Â  Â  Â  max-width: 90%; /* Responsive width */
Â  Â  Â  Â  Â  Â  background-color: rgba(255, 255, 255, 0.7);
Â  Â  Â  Â  Â  Â  border-radius: 0.75rem; /* Adjusted border-radius for the larger size */
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
Â  Â  Â  Â  Â  Â  z-index: 1001;
Â  Â  Â  Â  Â  Â  padding: 0.75rem; /* Adjusted padding for the larger size */
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  font-size: 100%; /* Kept font size consistent for readability */
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: #333;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* New CSS for the wiggle animation */
Â  Â  Â  Â  @keyframes wiggle-up-down {
Â  Â  Â  Â  Â  Â  0%, 100% {
Â  Â  Â  Â  Â  Â  Â  Â  transform: translateY(0);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  50% {
Â  Â  Â  Â  Â  Â  Â  Â  transform: translateY(-5px);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  .wiggle-text {
Â  Â  Â  Â  Â  Â  display: inline-block;
Â  Â  Â  Â  Â  Â  animation: wiggle-up-down 1s ease-in-out infinite;
Â  Â  Â  Â  }
Â  Â  </style>
Â  Â  Â  Â  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
</head>
<body class="bg-gray-100">

Â  Â  <div class="widget-container">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="map-container rounded-b-xl">
Â  Â  Â  Â  Â  Â  <div id="map"></div>
Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  <div id="timer-container" class="timer-container"></div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  Â  Â  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
Â  Â Â 
Â  Â  <script>
Â  Â  Â  Â  (function() {
Â  Â  Â  Â  Â  Â  // !!! IMPORTANT: Replace "YOUR_API_KEY_HERE" with your new API key !!!
Â  Â  Â  Â  Â  Â  const API_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjBjMGUyMGY3YmM4NzQwNWY5ZDUyYzE4Y2VkMjI1Mjc1IiwiaCI6Im11cm11cjY0In0=";
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // The minimum distance the user must move (in meters) before a new API call is made.
Â  Â  Â  Â  Â  Â  // This prevents excessive API calls while still providing live updates.
Â  Â  Â  Â  Â  Â  const minDistanceForApiCall = 500;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let map = null;
Â  Â  Â  Â  Â  Â  let startLocation = null;
Â  Â  Â  Â  Â  Â  let destinationLocation = null;
Â  Â  Â  Â  Â  Â  let lastKnownPosition = null; // Store the last position to check for significant movement
Â  Â  Â  Â  Â  Â  let lastApiCallPosition = null; // Store the last position from which we made an API call
Â  Â  Â  Â  Â  Â  let startMarker = null;
Â  Â  Â  Â  Â  Â  let destinationMarker = null;
Â  Â  Â  Â  Â  Â  let currentRouteLayer = null;
Â  Â  Â  Â  Â  Â  let locationWatchId = null; // Store the watchPosition ID
Â  Â  Â  Â  Â  Â  let destinationName = null;
Â  Â  Â  Â  Â  Â  let timerContainer = null;

Â  Â  Â  Â  Â  Â  function init() {
Â  Â  Â  Â  Â  Â  Â  Â  // Initializing the map with zoom and attribution controls disabled
Â  Â  Â  Â  Â  Â  Â  Â  map = L.map('map', {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zoomControl: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attributionControl: false
Â  Â  Â  Â  Â  Â  Â  Â  }).setView([0, 0], 2);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subdomains: 'abcd'
Â  Â  Â  Â  Â  Â  Â  Â  }).addTo(map);

Â  Â  Â  Â  Â  Â  Â  Â  timerContainer = document.getElementById('timer-container');

Â  Â  Â  Â  Â  Â  Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  Â  Â  Â  Â  Â  Â  const destination = urlParams.get('destination');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (destination) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  processDestination(destination);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startLocation = [37.5665, 126.9780];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map.setView(startLocation, 12);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  function onLocationSuccess(position) {
Â  Â  Â  Â  Â  Â  Â  Â  startLocation = [position.coords.latitude, position.coords.longitude];
Â  Â  Â  Â  Â  Â  Â  Â  setStartMarker();
Â  Â  Â  Â  Â  Â  Â  Â  map.setView(startLocation, 12);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  function onLocationError(error) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("Geolocation error:", error);
Â  Â  Â  Â  Â  Â  Â  Â  startLocation = [37.5665, 126.9780];
Â  Â  Â  Â  Â  Â  Â  Â  setStartMarker();
Â  Â  Â  Â  Â  Â  Â  Â  map.setView(startLocation, 12);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  function setStartMarker() {
Â  Â  Â  Â  Â  Â  Â  Â  Â const duckIcon = L.icon({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â iconUrl: 'duck.png',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â iconSize: [38, 38],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â iconAnchor: [19, 38],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â popupAnchor: [0, -38]
Â  Â  Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (startMarker) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startMarker.setLatLng(startLocation);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startMarker = L.marker(startLocation, { icon: duckIcon }).addTo(map)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .bindPopup("Your current location");
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  async function processDestination(destination) {
Â  Â  Â  Â  Â  Â  Â  Â  const getUserLocation = () => new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (navigator.geolocation) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reject(new Error("Geolocation not supported."));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const position = await getUserLocation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startLocation = [position.coords.latitude, position.coords.longitude];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let foundDestination = null;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Attempt 1: Try the original address as is.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  foundDestination = await tryGeocode(destination);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Attempt 2: If no result, try a simplified version of the address.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // This is especially useful for Korean addresses that might include apartment numbers
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // or other very specific details that confuse the geocoding service.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!foundDestination) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const addressParts = destination.split(' ');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const simplifiedAddress = addressParts.slice(0, -1).join(' ');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (simplifiedAddress.length > 0 && simplifiedAddress !== destination) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  foundDestination = await tryGeocode(simplifiedAddress);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Attempt 3: If still no result, try adding ", Seoul" as a final fallback.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!foundDestination) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  foundDestination = await tryGeocode(destination + ", Seoul");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (foundDestination) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const destPoint = foundDestination.features[0].geometry.coordinates;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  destinationLocation = [destPoint[1], destPoint[0]];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  destinationName = foundDestination.features[0].properties.label;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setStartMarker();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (destinationMarker) map.removeLayer(destinationMarker);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  destinationMarker = L.marker(destinationLocation).addTo(map);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounds = L.latLngBounds([startLocation, destinationLocation]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map.fitBounds(bounds, { padding: [20, 20] });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Initial API call
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastApiCallPosition = startLocation;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  getRouteAndTravelTime();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startLocationPolling();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If no match is found after all attempts, show a generic error.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const defaultMessage = "Address not found. ðŸ¤¯";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (startMarker) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â startMarker.bindPopup(defaultMessage).openPopup();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â L.marker([37.5665, 126.9780]).addTo(map).bindPopup(defaultMessage).openPopup();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error:", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let errorMessage = "ðŸ¤¯ GPS out or simplify the adress";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (startMarker) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startMarker.bindPopup(errorMessage).openPopup();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  L.marker([37.5665, 126.9780]).addTo(map).bindPopup(errorMessage).openPopup();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  async function tryGeocode(query) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geocodeUrl = `https://api.openrouteservice.org/geocode/search?api_key=${API_KEY}&text=${encodeURIComponent(query)}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geocodeResponse = await fetch(geocodeUrl);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!geocodeResponse.ok) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check for a specific API key error
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (geocodeResponse.status === 403) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Geocoding failed: Invalid API key.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error("Invalid API key. Please check your key or generate a new one.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const geocodeData = await geocodeResponse.json();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (geocodeData.features.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return geocodeData;
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Geocoding failed:", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // This function now uses the more battery-efficient watchPosition API
Â  Â  Â  Â  Â  Â  function startLocationPolling() {
Â  Â  Â  Â  Â  Â  Â  Â  // Clear any previous watch to prevent multiple listeners
Â  Â  Â  Â  Â  Â  Â  Â  if (locationWatchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.clearWatch(locationWatchId);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Use watchPosition to monitor for changes in the user's location
Â  Â  Â  Â  Â  Â  Â  Â  locationWatchId = navigator.geolocation.watchPosition(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (position) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newPosition = [position.coords.latitude, position.coords.longitude];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if this is the first position or if the user has moved significantly
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!lastKnownPosition) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastKnownPosition = newPosition;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lastLatLng = L.latLng(lastKnownPosition);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newLatLng = L.latLng(newPosition);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distanceMoved = lastLatLng.distanceTo(newLatLng);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Always update the duck's location to provide a live-tracking feel
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startLocation = newPosition;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setStartMarker();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if the user has moved more than the minimum distance for a new API call
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (lastApiCallPosition) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lastApiLatLng = L.latLng(lastApiCallPosition);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distanceSinceLastCall = lastApiLatLng.distanceTo(newLatLng);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (distanceSinceLastCall > minDistanceForApiCall) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Update the last API call position and fetch a new route
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastApiCallPosition = newPosition;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  getRouteAndTravelTime();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Update the last known position for the next movement check
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastKnownPosition = newPosition;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (error) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Real-time geolocation error:", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If an error occurs, stop watching the position to save resources
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (locationWatchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.clearWatch(locationWatchId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  function decodePolyline(encoded) {
Â  Â  Â  Â  Â  Â  Â  Â  let points = [];
Â  Â  Â  Â  Â  Â  Â  Â  let index = 0, len = encoded.length;
Â  Â  Â  Â  Â  Â  Â  Â  let lat = 0, lng = 0;

Â  Â  Â  Â  Â  Â  Â  Â  while (index < len) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let b, shift = 0, result = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  do {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  b = encoded.charCodeAt(index++) - 63;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result |= (b & 0x1f) << shift;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  shift += 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } while (b >= 0x20);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lat += dlat;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  shift = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  do {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  b = encoded.charCodeAt(index++) - 63;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result |= (b & 0x1f) << shift;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  shift += 5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } while (b >= 0x20);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lng += dlng;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  points.push([lat / 1e5, lng / 1e5]);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return points;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  async function getRouteAndTravelTime() {
Â  Â  Â  Â  Â  Â  Â  Â  if (!startLocation || !destinationLocation) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Calculate distance between current location and destination
Â  Â  Â  Â  Â  Â  Â  Â  const startLatLng = L.latLng(startLocation);
Â  Â  Â  Â  Â  Â  Â  Â  const destinationLatLng = L.latLng(destinationLocation);
Â  Â  Â  Â  Â  Â  Â  Â  const distance = startLatLng.distanceTo(destinationLatLng);

Â  Â  Â  Â  Â  Â  Â  Â  // Check if the user is within 350 meters of the destination
Â  Â  Â  Â  Â  Â  Â  Â  if (distance < 350) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timerContainer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Apply the new wiggle-text class
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerContainer.innerHTML = `<b><span class="wiggle-text">Almost! ðŸ¥³</span></b>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentRouteLayer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map.removeLayer(currentRouteLayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentRouteLayer = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Stop polling for new location data to save battery
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (locationWatchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.clearWatch(locationWatchId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  locationWatchId = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // Exit the function
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // If not close, proceed with fetching the route as normal
Â  Â  Â  Â  Â  Â  Â  Â  const orsCoords = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [startLocation[1], startLocation[0]],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [destinationLocation[1], destinationLocation[0]]
Â  Â  Â  Â  Â  Â  Â  Â  ];

Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const directionsUrl = `https://api.openrouteservice.org/v2/directions/cycling-regular`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const payload = { coordinates: orsCoords };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const response = await fetch(directionsUrl, {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  headers: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Authorization': API_KEY
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  body: JSON.stringify(payload)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!response.ok) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const errorData = await response.json().catch(() => ({}));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const errorMessage = errorData.error?.message || `API request failed with status: ${response.status}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Add specific check for API key error here too
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (response.status === 403) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â throw new Error("Invalid API key. Please check your key or generate a new one.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`An error occurred: ${errorMessage}.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const data = await response.json();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (data && data.routes && data.routes.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const route = data.routes[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const encodedGeometry = route.geometry;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const durationInSeconds = route.summary.duration;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const routeCoordinates = decodePolyline(encodedGeometry);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentRouteLayer) map.removeLayer(currentRouteLayer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentRouteLayer = L.polyline(routeCoordinates, {color: 'skyblue'}).addTo(map);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const durationInMinutes = Math.round(durationInSeconds / 60);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Update the new floating timer window instead of a popup
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timerContainer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerContainer.innerHTML = `<b>${durationInMinutes} min</b>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bounds = L.latLngBounds([startLocation, destinationLocation]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map.fitBounds(bounds, { padding: [20, 20] });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (timerContainer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â timerContainer.innerHTML = "ðŸ¤¯ GPS out or simplify the address";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Routing Error:", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (timerContainer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timerContainer.innerHTML = error.message.includes("Invalid API key") ? "Invalid API Key ðŸ¤¯" : "ðŸ¤¯ GPS out or simplify the address";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (locationWatchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.clearWatch(locationWatchId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  locationWatchId = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  window.addEventListener('load', init);
Â  Â  Â  Â  })();
Â  Â  </script>
</body>
</html>
